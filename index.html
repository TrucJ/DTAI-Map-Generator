<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Hexmap with Responsive Canvas</title>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            overflow: hidden; /* tránh cuộn trang */
        }
        .container {
            display: flex;
            height: 100vh;
        }
        .left-panel {
            flex: 1;
            position: relative;
            background-color: #f9f9f9;
        }
        /* Canvas chiếm 100% kích thước của left-panel */
        canvas {
            width: 100%;
            height: 100%;
            display: block;
            background-color: #fff;
            cursor: grab;
        }
        .right-panel {
            width: 250px;
            padding: 20px;
            box-sizing: border-box;
            border-left: 1px solid #ccc;
            background-color: #eee;
            text-align: center;
            overflow-y: auto;
        }
        .right-panel h2 {
            margin-top: 0;
        }
        /* Hàng 1: Map size (label & select) */
        #map-size-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        /* Hàng 5: Checkbox với label "Ask before clear" */
        #confirm-group label {
            font-size: 14px;  /* chữ nhỏ hơn */
            margin-top: 10px; /* margin top lớn hơn */
        }
        /* Hàng 2,3,4: Mỗi nút điều khiển nằm trên 1 hàng riêng */
        .tile-container {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            margin: 10px auto;
        }
        .tile-button-wrapper {
            width: 60px;
            height: 60px;
            clip-path: polygon(25% 6.7%, 75% 6.7%, 100% 50%, 75% 93.3%, 25% 93.3%, 0% 50%);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            background-color: transparent;
        }
        /* Khi active, đặt background-color trực tiếp */
        .tile-button-wrapper.active {
            background-color: black;
        }
        .tile-button-content {
            width: 100%;
            height: 100%;
            clip-path: inherit;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 18px;
        }
        .tile-button-wrapper.active .tile-button-content {
            width: calc(100% - 6px);
            height: calc(100% - 6px);
        }
        .tile-button-wrapper.tile-danger .tile-button-content {
            background-color: red;
            color: black;
        }
        .tile-button-wrapper.tile-shield .tile-button-content {
            background-color: skyblue;
            color: black;
        }
        .tile-button-wrapper.tile-gold .tile-button-content {
            background-color: yellow;
            color: black;
        }
        .tile-count {
            margin-left: 8px;
            font-size: 16px;
            font-weight: bold;
        }
        select {
            width: 60%;
            padding: 8px;
            font-size: 16px;
        }
        /* Hàng 6 và Hàng 7: Các nút hành động */
        .action-container {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
        }
        .action-container button {
            padding: 8px 16px;
            font-size: 16px;
            cursor: pointer;
            width: 100px; /* Đảm bảo tất cả các button có cùng độ dài */
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
<div class="container">
    <!-- Hexmap Panel -->
    <div class="left-panel">
        <canvas id="hexMap"></canvas>
    </div>
    <!-- Control Panel -->
    <div class="right-panel">
        <h2>Control Panel</h2>

        <!-- Hàng 1: Map size -->
        <div class="control-group" id="map-size-group">
            <label for="cellCount">Map size</label>
            <select id="cellCount">
                <option value="8">8x8x8</option>
                <option value="9">9x9x9</option>
                <option value="10" selected>10x10x10</option>
                <option value="11">11x11x11</option>
                <option value="12">12x12x12</option>
            </select>
        </div>

        <!-- Hàng 2: Danger control -->
        <div class="control-group">
            <div class="tile-container">
                <div class="tile-button-wrapper tile-danger" data-tile="danger">
                    <div class="tile-button-content">D</div>
                </div>
                <div class="tile-count" id="count-danger">x 0</div>
            </div>
        </div>

        <!-- Hàng 3: Shield control -->
        <div class="control-group">
            <div class="tile-container">
                <div class="tile-button-wrapper tile-shield" data-tile="shield">
                    <div class="tile-button-content">S</div>
                </div>
                <div class="tile-count" id="count-shield">x 0</div>
            </div>
        </div>

        <!-- Hàng 4: Gold control -->
        <div class="control-group">
            <div class="tile-container">
                <div class="tile-button-wrapper tile-gold" data-tile="gold">
                    <div class="tile-button-content">G</div>
                </div>
                <div class="tile-count" id="count-gold">x 0</div>
            </div>
        </div>

        <!-- Hàng 5: Checkbox confirm -->
        <div class="control-group" id="confirm-group">
            <label>
                <input type="checkbox" id="confirmCheckbox" checked>
                Ask before clear
            </label>
        </div>

        <!-- Hàng 6: Clear and Random buttons -->
        <div class="control-group action-container">
            <button id="clearBtn" disabled>Clear</button>
            <button id="randomBtn">Random</button>
        </div>

        <!-- Hàng 7: Download and Upload buttons -->
        <div class="control-group action-container">
            <button id="downloadBtn">Download</button>
            <button id="uploadBtn">Upload</button>
            <input type="file" id="uploadInput" style="display: none;" accept=".txt">
        </div>
    </div>
</div>

<script>
  // --- Phần Hexmap ---
  let cellsPerEdge = parseInt(document.getElementById('cellCount').value);
  let radius = cellsPerEdge - 1;
  const hexSize = 30;
  let scale = 1;

  const canvas = document.getElementById("hexMap");
  const ctx = canvas.getContext("2d");
  let centerX = canvas.width / 2;
  let centerY = canvas.height / 2;

  const tileColors = {
    danger: "red",
    shield: "skyblue",
    gold: "yellow"
  };
  const tileLabels = {
    danger: "D",
    shield: "S"
  };

  let selectedCells = {};
  let activeTile = null;
  let offsetX = 0, offsetY = 0;
  let isDragging = false, startDragX = 0, startDragY = 0;
  let hasMoved = false;

  function getCyclicKeys(cube) {
    let keys = [];
    keys.push(`${cube.q},${cube.r},${cube.s}`);
    keys.push(`${cube.r},${cube.s},${cube.q}`);
    keys.push(`${cube.s},${cube.q},${cube.r}`);
    return [...new Set(keys)];
  }
  function cubeToAxial(cube) {
    return { q: cube.q, r: cube.r };
  }
  function axialToPixel(axial) {
    const size = hexSize * scale;
    const x = size * Math.sqrt(3) * (axial.q + axial.r / 2);
    const y = size * 3/2 * axial.r;
    return { x, y };
  }
  function cubeToPixel(cube) {
    return axialToPixel(cubeToAxial(cube));
  }
  function getHexCornerCoords(cx, cy) {
    const corners = [];
    const size = hexSize * scale;
    for (let i = 0; i < 6; i++) {
      const angle_deg = 60 * i - 30;
      const angle_rad = Math.PI / 180 * angle_deg;
      corners.push({
        x: cx + size * Math.cos(angle_rad),
        y: cy + size * Math.sin(angle_rad)
      });
    }
    return corners;
  }
  function drawHex(cx, cy, label, fillColor) {
    const corners = getHexCornerCoords(cx, cy);
    ctx.beginPath();
    ctx.moveTo(corners[0].x, corners[0].y);
    for (let i = 1; i < corners.length; i++) {
      ctx.lineTo(corners[i].x, corners[i].y);
    }
    ctx.closePath();
    if (fillColor) {
      ctx.fillStyle = fillColor;
      ctx.fill();
    }
    ctx.stroke();
    if (label) {
      ctx.font = "10px Arial";
      ctx.fillStyle = "black";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(label, cx, cy);
    }
  }
  function drawMap() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (let q = -radius; q <= radius; q++) {
      const r1 = Math.max(-radius, -q - radius);
      const r2 = Math.min(radius, -q + radius);
      for (let r = r1; r <= r2; r++) {
        const s = -q - r;
        const cube = { q, r, s };
        const pixel = cubeToPixel(cube);
        const px = pixel.x + centerX + offsetX;
        const py = pixel.y + centerY + offsetY;
        const key = `${q},${r},${s}`;
        let tileObj = selectedCells[key];
        let fillColor;
        let label = "";
        if (tileObj) {
          if (tileObj.type === "gold") {
            label = tileObj.count.toString();
          } else {
            label = tileLabels[tileObj.type];
          }
          fillColor = tileColors[tileObj.type];
        } else {
          if (q > 0 && r < 0) {
            fillColor = "mistyrose";
          } else if (r > 0 && s < 0) {
            fillColor = "honeydew";
          } else if (s > 0 && q < 0) {
            fillColor = "aliceblue";
          } else {
            fillColor = "white";
          }
        }
        drawHex(px, py, label, fillColor);
      }
    }
    updateCounts();
  }
  function pixelToAxial(px, py) {
    const x = px - centerX - offsetX;
    const y = py - centerY - offsetY;
    const q = (Math.sqrt(3)/3 * x - 1/3 * y) / (hexSize * scale);
    const r = (2/3 * y) / (hexSize * scale);
    return { q, r };
  }
  function axialToCube(axial) {
    return { q: axial.q, r: axial.r, s: -axial.q - axial.r };
  }
  function cubeRound(cube) {
    let rq = Math.round(cube.q);
    let rr = Math.round(cube.r);
    let rs = Math.round(cube.s);
    const q_diff = Math.abs(rq - cube.q);
    const r_diff = Math.abs(rr - cube.r);
    const s_diff = Math.abs(rs - cube.s);
    if (q_diff > r_diff && q_diff > s_diff) {
      rq = -rr - rs;
    } else if (r_diff > s_diff) {
      rr = -rq - rs;
    } else {
      rs = -rq - rr;
    }
    return { q: rq, r: rr, s: rs };
  }
  function pixelToCube(px, py) {
    const axial = pixelToAxial(px, py);
    const cube = axialToCube(axial);
    return cubeRound(cube);
  }
  canvas.addEventListener("mousedown", function(event) {
    isDragging = true;
    hasMoved = false;
    startDragX = event.clientX;
    startDragY = event.clientY;
    canvas.style.cursor = "grabbing";
  });
  canvas.addEventListener("mousemove", function(event) {
    if (isDragging) {
      const dx = event.clientX - startDragX;
      const dy = event.clientY - startDragY;
      if (Math.abs(dx) > 2 || Math.abs(dy) > 2) {
        hasMoved = true;
      }
      offsetX += dx;
      offsetY += dy;
      startDragX = event.clientX;
      startDragY = event.clientY;
      drawMap();
    }
  });
  canvas.addEventListener("mouseup", function() {
    isDragging = false;
    canvas.style.cursor = "grab";
  });
  canvas.addEventListener("mouseleave", function() {
    isDragging = false;
    canvas.style.cursor = "grab";
  });
  canvas.addEventListener("wheel", function(event) {
    event.preventDefault();
    if (event.deltaY < 0) {
      scale *= 1.05;
    } else {
      scale /= 1.05;
    }
    drawMap();
  });

  function updateCanvasSize() {
    const dpr = window.devicePixelRatio || 1;
    const leftPanel = document.querySelector('.left-panel');
    const width = leftPanel.clientWidth;
    const height = leftPanel.clientHeight;
    // Cập nhật kích thước canvas theo devicePixelRatio
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    canvas.style.width = width + "px";
    canvas.style.height = height + "px";

    // Reset transform trước khi scale
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(dpr, dpr);

    // Cập nhật tâm của map dựa trên kích thước mới
    centerX = width / 2;
    centerY = height / 2;

    drawMap();
  }

  window.addEventListener('load', updateCanvasSize);
  window.addEventListener('resize', updateCanvasSize);

  canvas.addEventListener("click", function(event) {
    if (hasMoved) return;
    const rect = canvas.getBoundingClientRect();
    const clickX = event.clientX - rect.left;
    const clickY = event.clientY - rect.top;
    const cube = pixelToCube(clickX, clickY);
    if (Math.max(Math.abs(cube.q), Math.abs(cube.r), Math.abs(cube.s)) <= radius) {
      const keys = getCyclicKeys(cube);
      if (!activeTile) return;
      if (activeTile === "danger" || activeTile === "shield") {
        if (selectedCells[keys[0]] && selectedCells[keys[0]].type === activeTile) {
          keys.forEach(key => delete selectedCells[key]);
        } else {
          const obj = { type: activeTile };
          keys.forEach(key => selectedCells[key] = obj);
        }
      } else if (activeTile === "gold") {
        if (!selectedCells[keys[0]] || selectedCells[keys[0]].type !== "gold") {
          const obj = { type: "gold", count: 1 };
          keys.forEach(key => selectedCells[key] = obj);
        } else {
          let newCount = selectedCells[keys[0]].count + 1;
          if (newCount > 6) {
            keys.forEach(key => delete selectedCells[key]);
          } else {
            selectedCells[keys[0]].count = newCount;
            keys.forEach(key => selectedCells[key] = selectedCells[keys[0]]);
          }
        }
      }
      drawMap();
    }
  });

  document.addEventListener("keydown", function(event) {
    // Lấy phím được nhấn dưới dạng chữ thường
    const key = event.key.toLowerCase();
    if(key === "d" || key === "s" || key === "g") {
      // Chuyển đổi phím sang tile type
      let tileType = "";
      if(key === "d") tileType = "danger";
      else if(key === "s") tileType = "shield";
      else if(key === "g") tileType = "gold";

      // Nếu tile đang active đã trùng với tileType, thì unactive (tắt active)
      if(activeTile === tileType) {
        tileWrappers.forEach(wrapper => wrapper.classList.remove('active'));
        activeTile = null;
      } else {
        // Ngược lại, tắt active của các nút khác và active nút tương ứng
        tileWrappers.forEach(wrapper => {
          wrapper.classList.remove('active');
          if(wrapper.getAttribute("data-tile") === tileType) {
            wrapper.classList.add('active');
          }
        });
        activeTile = tileType;
      }
    }
  });

  let prevCellsPerEdge = cellsPerEdge;
  const confirmCheckbox = document.getElementById('confirmCheckbox');
  document.getElementById('cellCount').addEventListener('change', function() {
    let newCellsPerEdge = parseInt(this.value);

    // Nếu map size mới nhỏ hơn map size cũ và checkbox "Ask before clear" được chọn
    if (newCellsPerEdge < prevCellsPerEdge && confirmCheckbox.checked && Object.keys(selectedCells).length > 0) {
      let confirmed = confirm("Changing the map size will remove cells outside the new boundaries. Do you want to proceed?");
      if (!confirmed) {
        this.value = prevCellsPerEdge;
        return;
      }
    }
    // Cập nhật map size
    cellsPerEdge = newCellsPerEdge;
    radius = cellsPerEdge - 1;

    // Lọc lại các ô đã có, chỉ giữ lại những ô nằm trong vùng mới
    let newSelectedCells = {};
    for (let key in selectedCells) {
      let parts = key.split(",");
      let q = Math.abs(parseInt(parts[0]));
      let r = Math.abs(parseInt(parts[1]));
      let s = Math.abs(parseInt(parts[2]));
      if (Math.max(q, r, s) <= radius) {
        newSelectedCells[key] = selectedCells[key];
      }
    }
    selectedCells = newSelectedCells;
    prevCellsPerEdge = cellsPerEdge;
    drawMap();
  });

  const tileWrappers = document.querySelectorAll('.tile-button-wrapper');
  tileWrappers.forEach(wrapper => {
    wrapper.addEventListener('click', function() {
      if (this.classList.contains('active')) {
        this.classList.remove('active');
        activeTile = null;
      } else {
        tileWrappers.forEach(w => w.classList.remove('active'));
        this.classList.add('active');
        activeTile = this.getAttribute('data-tile');
      }
    });
  });

  const clearBtn = document.getElementById('clearBtn');
  clearBtn.addEventListener('click', function() {
    if (Object.keys(selectedCells).length > 0) {
      if (confirmCheckbox.checked) {
        let confirmed = confirm("Are you sure you want to clear the map?");
        if (!confirmed) return;
      }
      selectedCells = {};
      drawMap();
    }
  });

  const downloadBtn = document.getElementById('downloadBtn');
  downloadBtn.addEventListener('click', function() {
    let N = cellsPerEdge;
    let keys = Object.keys(selectedCells);
    let C = keys.length;
    let lines = [];
    lines.push(N);
    lines.push(C);
    keys.forEach(key => {
      let parts = key.split(",");
      let q = parts[0], r = parts[1], s = parts[2];
      let tile = selectedCells[key];
      let V;
      if (tile.type === "gold") {
        V = tile.count;
      } else if (tile.type === "danger") {
        V = "D";
      } else if (tile.type === "shield") {
        V = "S";
      }
      lines.push(`${q} ${r} ${s} ${V}`);
    });
    let fileContent = lines.join("\n");
    let blob = new Blob([fileContent], { type: "text/plain" });
    let a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "map.txt";
    a.click();
  });

  const randomBtn = document.getElementById('randomBtn');
  randomBtn.addEventListener('click', function() {
    if (confirmCheckbox.checked && Object.keys(selectedCells).length > 0) {
      let confirmed = confirm("The map will be cleared. Do you want to proceed?");
      if (!confirmed) return;
    }
    selectedCells = {};
    let groups = {};
    for (let q = -radius; q <= radius; q++) {
      const r1 = Math.max(-radius, -q - radius);
      const r2 = Math.min(radius, -q + radius);
      for (let r = r1; r <= r2; r++) {
        const s = -q - r;
        const cube = { q, r, s };
        const keys = getCyclicKeys(cube);
        let canonical = keys.slice().sort().join("|");
        if (!(canonical in groups)) {
          groups[canonical] = keys;
        }
      }
    }
    const groupArray = Object.values(groups);

    // Chọn 1 group (có 3 phần tử) để gán Shield sao cho tổng shield = 3
    const nonCenterGroups = groupArray.filter(g => g.length === 3);
    if (nonCenterGroups.length > 0) {
      const shieldGroup = nonCenterGroups[Math.floor(Math.random() * nonCenterGroups.length)];
      shieldGroup.forEach(key => {
        selectedCells[key] = { type: "shield" };
      });
    }

    const prob = 0.3;
    groupArray.forEach(group => {
      if (selectedCells.hasOwnProperty(group[0])) return;
      if (Math.random() < prob) {
        const randomType = (Math.random() < 0.5) ? "danger" : "gold";
        let obj;
        if (randomType === "gold") {
          obj = { type: "gold", count: Math.floor(Math.random() * 6) + 1 };
        } else {
          obj = { type: "danger" };
        }
        group.forEach(key => selectedCells[key] = obj);
      }
    });

    drawMap();
  });

  const uploadBtn = document.getElementById('uploadBtn');
  const uploadInput = document.getElementById('uploadInput');
  uploadBtn.addEventListener('click', function() {
    uploadInput.click();
  });
  uploadInput.addEventListener('change', function() {
    if (this.files.length === 0) return;
    const file = this.files[0];
    const reader = new FileReader();
    reader.onload = function(e) {
      const content = e.target.result;
      const lines = content.split(/\r?\n/);
      if (lines.length < 2) {
        alert("Invalid file format.");
        return;
      }
      const N = parseInt(lines[0].trim());
      if (isNaN(N)) {
        alert("Invalid map size in file.");
        return;
      }
      cellsPerEdge = N;
      radius = cellsPerEdge - 1;
      document.getElementById('cellCount').value = N;
      selectedCells = {};
      for (let i = 2; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;
        const parts = line.split(" ");
        if (parts.length < 4) continue;
        const q = parts[0], r = parts[1], s = parts[2], V = parts[3];
        let obj;
        if (V === "D") {
          obj = { type: "danger" };
        } else if (V === "S") {
          obj = { type: "shield" };
        } else {
          const count = parseInt(V);
          if (isNaN(count)) continue;
          obj = { type: "gold", count: count };
        }
        const key = `${q},${r},${s}`;
        selectedCells[key] = obj;
      }
      drawMap();
    };
    reader.readAsText(file);
  });

  function updateCounts() {
    let countDanger = 0, countShield = 0, countGold = 0;
    for (let key in selectedCells) {
      const obj = selectedCells[key];
      if (obj.type === "danger") {
        countDanger++;
      } else if (obj.type === "shield") {
        countShield++;
      } else if (obj.type === "gold") {
        countGold += obj.count;
      }
    }
    document.getElementById("count-danger").textContent = "x " + countDanger;
    document.getElementById("count-shield").textContent = "x " + countShield;
    document.getElementById("count-gold").textContent = "x " + countGold;

    if (Object.keys(selectedCells).length === 0) {
      clearBtn.disabled = true;
    } else {
      clearBtn.disabled = false;
    }
  }

  drawMap();
</script>
</body>
</html>
